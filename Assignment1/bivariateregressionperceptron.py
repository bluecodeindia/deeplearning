# -*- coding: utf-8 -*-
"""BivariateRegressionPerceptron.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1RlqA-1n-7BZeBFi_rEqFPxynpKK9hFqm
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits import mplot3d
import math
# %matplotlib inline

plt.style.use('ggplot')
plt.rcParams['figure.figsize'] = (10, 10)

from google.colab import drive
drive.mount('/content/drive')

File="/content/drive/My Drive/Deeplearning/Group31_Assignment1/"

def readData(file):
    data=pd.read_csv(file+".csv",",",header=None)
    data=np.array(data.values)
    return data

def train_test_split(arr, test):
    y=np.full(len(arr),1)
    
    train=     np.array([y[:-int(len(arr)*(test))],arr[:-int(len(arr)*(test)),0],arr[:-int(len(arr)*(test)),1],arr[:-int(len(arr)*(test)),2]])
    test=      np.array([y[-int(len(arr)*test): ],arr[-int(len(arr)*test): ,0],arr[-int(len(arr)*test): ,1],arr[-int(len(arr)*test): ,2]])
    
    return train.T,  test.T

def plot_data(red,green, blue,title):
    plt.scatter(red[0],red[1],color='red')
    plt.scatter(green[0],green[1],color='green')
    plt.scatter(blue[0],blue[1],color='blue')
    plt.title(title)
    plt.savefig(title)
    plt.show()

Folder=[File+"Group31/Regression/BivariateData/31"]

for k in Folder:
        
    folder=k
    data=  readData(k)
    
    train_data, Test=  train_test_split(data,0.20)

# Decision boundary
def generate_values_boundary(data,weights1,ttl):
#     %matplotlib notebook
    min_x=min(data[:,1])
    max_x=max(data[:,1])

    W1=weights1[1]
    W2=weights1[2]
    b= weights1[0]
   
#     y_pred   = W*data[:,0]+b
#     plt.plot(data[:,0],y_pred,color='b',label='p1')
    z= W1*data[:,0]+W2*data[:,1]+b
    print(z)                 
    fig = plt.figure()
    ax = plt.axes(projection='3d')
    ax.scatter3D(data[:,0],data[:,1],z,zorder=15,color='#99C2DE',alpha=0.2)
    ax.scatter3D(data[:,0],data[:,1],data[:,2],marker='o',color='#EAA358',edgecolors='black')
    
    # rotate the axes and update
#     for angle in range(0, 360):
#         ax.view_init(30, angle)
#         plt.draw()
#         plt.pause(.001)
    
    
    print(ttl)
#     plt.xlabel("x1")  # add X-axis label 
#     plt.ylabel("x2") 
#     plt.savefig(ttl+'.png',bbox_inches = 'tight')
    plt.show()





fig = plt.figure()
ax = plt.axes(projection='3d')
ax.scatter3D(data[:,0],data[:,1],data[:,2],marker='D',color='#EAA358',edgecolors='black')
# xx, yy = np.meshgrid(range(10), range(10))
# z = (9 - xx - yy) / 2 
# ax.plot_surface(xx, yy, z, alpha=0.5)

def perceptron(weights,input,log):
    
    predict=np.dot(weights,input)

                
    return predict

def network(inputs,epoch,log):
    

    w1=0.2
    w2=0.3
    bias=0.1
    cls1=0
    l_rate=0.1
    epoch_error=list()
    error1=0
    error2=0
    error3=0
    error=0
    error_vector1=[0,0,0]
    weights=np.array([bias,w1,w2])
    np.random.shuffle(inputs)
    for j in range(epoch):
        
        error1=0
        error2=0
        error3=0
        error=0

        error_vector1[2]=0
        for i in range(len(inputs)):

            expected=inputs[i][3]
            
            
            predict=perceptron(weights,inputs[i][0:3],log)
            
            E=(predict-expected)
            error1=error1+E*inputs[i][1]
            error2=error2+E*inputs[i][2]
            error3=error3+E
            error=error+E*E
            
        error1=error1/len(inputs)
        error2=error2/len(inputs)
        error3=error3/len(inputs)
        error= error/len(inputs)
        weights=[weights[0]-l_rate*(2*error3),weights[1]-l_rate*(2*error1),weights[2]-l_rate*(2*error2)]
        epoch_error.append(error)
        
    return weights,epoch_error

def cross_validation(k,Arr):



    length1=int(len(Arr)*0.25)

    
    M1,M2,M3,M4=Arr[:length1].copy(),Arr[length1:2*length1],Arr[2*length1:3*length1],Arr[3*length1:4*length1]
   
    if k==1:
        M=np.concatenate((M2,M3,M4))
        V=M1
    if k==2:
        M=np.concatenate((M1,M3,M4))
        V=M2
    if k==3:
        M=np.concatenate((M1,M2,M4))
        V=M3
    if k==4:
        M=np.concatenate((M1,M2,M3))
        V=M4


    
    
    return M, V

k=4 # k=1, 2, 3, 4 for the cross validation, where 1 is Fold-1
plt.rcParams['figure.figsize'] = (10, 10)

Train,Validation=cross_validation(k,train_data)

weights,error=network(Train,epoch=100,log=1)

plt.plot(error)
plt.xlabel("Epochs")  # add X-axis label 
plt.ylabel("Error")  # add Y-axis label 
plt.title("Error Plot")  # add title 
plt.savefig('LS_Error.png',bbox_inches = 'tight')

weights

generate_values_boundary(data,weights,'Regression')

def test(inputs,weights,log):
    

        error=0


        for i in range(len(inputs)):

            expected=inputs[i][3]
            
            
            predict=perceptron(weights,inputs[i][0:3],log)
            
            E=(predict-expected)
            error=error+E*E
            
        error= error/len(inputs)
        
        return error

test(Train,weights,1)

test(Val,weights,1)

test(Test,weights,1)

